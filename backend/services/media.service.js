import Media from '#models/media.model.js';
import mediaDao from '#daos/media.dao.js';
import {BadRequestError, InternalServerError} from '#errors/AppError.js';
import {postgresInstance} from '#db/postgres.js';
import path from 'path';
import fs from 'fs/promises';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

// Get __dirname equivalent for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

class MediaService {
    constructor(mediaDao) {
        this.mediaDao = mediaDao;
        this.uploadDir = path.join(__dirname, '..', 'public', 'uploads');
    }

    /**
     * Creates a media record for an uploaded file.
     * @param {string} uploaderUserId - The ID of the user uploading the file.
     * @param {Object} file - The uploaded file object from multer.
     * @param {string} file.path - The temporary path where multer stored the file.
     * @param {string} file.filename - The filename generated by multer.
     * @param {string} file.originalname - The original name of the file.
     * @param {string} file.mimetype - The MIME type of the file.
     * @param {number} file.size - The size of the file in bytes.
     * @returns {Promise<Media>} The created media record.
     * @throws {BadRequestError} If the file is invalid or missing required fields.
     * @throws {InternalServerError} If file operations fail.
     */
    async createMediaRecord(uploaderUserId, file) {
        if (!file || !file.path || !file.filename || !file.originalname || !file.mimetype || !file.size) {
            throw new BadRequestError('Invalid file upload: Missing required file information.');
        }

        // Ensure upload directory exists
        try {
            await fs.mkdir(this.uploadDir, {recursive: true});
        } catch (error) {
            console.error('[MediaService] Error creating upload directory:', error);
            throw new InternalServerError('Failed to create upload directory.');
        }

        // Use the filename generated by multer
        const filepath = path.join(this.uploadDir, file.filename);

        try {
            // Log the move operation for debugging
            console.log(`[MediaService] Moving file from ${file.path} to ${filepath}`);
            
            // Copy the file first, then delete the original
            await fs.copyFile(file.path, filepath);
            await fs.unlink(file.path);
            console.log(`[MediaService] Successfully moved file to ${filepath}`);

            // Create media record with relative path
            const relativePath = path.join('/uploads', file.filename);
            const media = new Media(
                null,
                uploaderUserId,
                relativePath, // Store only the relative path
                this._getMediaType(file.mimetype),
                file.mimetype,
                file.size
            );

            // Save to database within a transaction
            return await postgresInstance.transaction(async (trx) => {
                return await this.mediaDao.create(media, trx);
            });
        } catch (error) {
            // Clean up the file if database operation fails
            try {
                if (await fs.access(filepath).then(() => true).catch(() => false)) {
                    await fs.unlink(filepath).catch(() => {});
                }
            } catch (unlinkError) {
                console.error('[MediaService] Error cleaning up file after failed upload:', unlinkError);
            }

            console.error('[MediaService] Error creating media record:', error);
            if (error instanceof BadRequestError) {
                throw error;
            }
            throw new InternalServerError(`Failed to process uploaded file: ${error.message}`);
        }
    }

    /**
     * Deletes a media record and its associated file.
     * @param {string} mediaId - The ID of the media record to delete.
     * @returns {Promise<boolean>} True if the record and file were deleted.
     * @throws {InternalServerError} If deletion fails.
     */
    async deleteMedia(mediaId) {
        try {
            // Get the media record first to get the file path
            const media = await this.mediaDao.getById(mediaId);
            if (!media) {
                return false;
            }

            // Delete within a transaction
            const deleted = await postgresInstance.transaction(async (trx) => {
                const success = await this.mediaDao.deleteById(mediaId, trx);
                if (success) {
                    // Delete the file
                    try {
                        await fs.unlink(media.url);
                    } catch (unlinkError) {
                        console.error(`[MediaService] Error deleting file for media ${mediaId}:`, unlinkError);
                        // Don't throw here, as the DB record is already deleted
                    }
                }
                return success;
            });

            return deleted;
        } catch (error) {
            console.error(`[MediaService] Error deleting media ${mediaId}:`, error);
            throw new InternalServerError('Failed to delete media record and file.');
        }
    }

    /**
     * Helper method to determine media type from MIME type.
     * @private
     * @param {string} mimeType - The MIME type of the file.
     * @returns {string} The media type (e.g., 'image', 'video').
     */
    _getMediaType(mimeType) {
        if (mimeType.startsWith('image/')) return 'image';
        if (mimeType.startsWith('video/')) return 'video';
        if (mimeType.startsWith('audio/')) return 'audio';
        return 'other';
    }
}

export default new MediaService(mediaDao); 